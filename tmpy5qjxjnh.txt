Eshan, I noticed that you have experienced working as a senior software engineer at Shairchart. Would you mind sharing a few key projects you worked on during your time there? Yes, so at Shairchart I was mostly inwardly working on a lot of backend projects. One of the biggest projects was to redesign the complete architecture for the messaging platform. Can you elaborate a bit on the scope of the project and the main challenges you faced while redesigning the messaging architecture? So the messaging architecture at Shairchart involved two microservices that we implemented. The first microservice was for the regular messaging flow and the second microservice is for a real-time messaging. So for the real-time messaging microservice we used Kafka to handle the message queue. What considerations did you make while selecting Kafka for your messaging architecture? So the requirement for the real-time microservice was that it has to be low latency and it has to be highly scalable. And Kafka is already known for its high performance and low latency and it is also horizontally scalable. So all this consideration made it the ideal choice for audience case. I enjoyed getting a better insight into your professional experience. Eshan, I have a few technical questions to better understand your fit for this role. Can you tell me what is database sharding? Data-based sharding is a type of partitioning in which separate part of the databases may be tables or other schemas are stored on different servers and possibly these server could be in different location. So a load balancer would basically direct the request to different servers based on what is accessed. And this improves the performance basically because the load has been shared across each server. Eshan, can you explain how database partitioning boosts performance and in what scenarios would it be beneficial to implement it? Data-based partitioning improves performance by dividing a very large table into different fractions. These fractions can then reside on different locations which highly improves the performance because now for an reader write you only have to access a part of the table instead of the full table. This should be used when one of the tables is really large. That's right. Now I have a few questions related to Cache. Could you explain the idea behind cache invalidation? Cache invalidation is basically the process of removing items from the cache because the cache is full and the numerator has to be stored there. I'm afraid that's incorrect. Can you break down the concept of a cache eviction policy? OK, right. A cache eviction is the process of removing or replacing items from a cache when the cache is full or basically the cache reaches its maximum capacity. Other multiple strategies that can be used for cache eviction, the common policy could be like first and first out or at least recently used. That's correct.